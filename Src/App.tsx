import React, { useEffect, useMemo, useRef, useState } from "react"; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";

// ============================================================= // LecturaRápida — MVP (PWA web, usable en celular) // Ejercicios incluidos: // 1) Test base WPM (palabras/min) con autoevaluación de comprensión // 2) RSVP (presentación rápida en serie) con control de WPM y tamaño // 3) Pacer (barra guía sobre texto) para ritmo y reducción de regresiones // 4) Tablas de Schulte (atención/percepción periférica) // 5) Periferia Flash (palabras en laterales manteniendo fijación) // 6) Plan diario con temporizador, metas y racha // 7) Progreso y métricas (localStorage) // =============================================================

// -------------------- Utilidades -------------------- const LS_KEY = "lecturaRapida_progress_v1"; const QS_KEY = "lecturaRapida_quizzes_v1";

function loadQuizzes() { try { const raw = localStorage.getItem(QS_KEY); return raw ? JSON.parse(raw) : { templates: [] }; } catch { return { templates: [] }; } } function saveQuizzes(data) { try { localStorage.setItem(QS_KEY, JSON.stringify(data)); } catch {} }

function ensureDefaultQuizzes() { try { const raw = localStorage.getItem(QS_KEY); const obj = raw ? JSON.parse(raw) : { templates: [] }; if (!obj.templates || obj.templates.length === 0) { obj.templates = [ { id: 'tpl-fundamentos-1', name: 'Comprensión — Fundamentos (I)', questions: [ { q: 'Según el texto de ejemplo, la lectura eficaz busca principalmente…', options: ['Aumentar velocidad sin perder comprensión', 'Memorizar palabra por palabra', 'Mover la cabeza para seguir el renglón', 'Vocalizar más fuerte'], correctIndex: 0 }, { q: '¿Qué se entrena para mejorar el ritmo de lectura?', options: ['Fijaciones más cortas y sacádicos más amplios', 'Parpadeo constante', 'Brillo de pantalla', 'Decir cada palabra en voz alta'], correctIndex: 0 }, { q: '¿Qué herramientas se mencionan para ajustar la cadencia?', options: ['RSVP o metrónomo visual', 'Audiolibros únicamente', 'Diccionarios', 'Cronómetro manual sin guía'], correctIndex: 0 } ] }, { id: 'tpl-transferencia-2', name: 'Comprensión — Transferencia (II)', questions: [ { q: 'En el entrenamiento, el “pacer visual” ayuda principalmente a…', options: ['Reducir regresiones', 'Aumentar regresiones', 'Traducir mentalmente', 'Leer en voz alta'], correctIndex: 0 }, { q: 'Para subir WPM de forma segura se sugiere…', options: ['Aumentar gradualmente si la comprensión ≥ 70%', 'Subir 100 WPM cada día', 'Focalizar solo en velocidad', 'Cerrar un ojo para concentrarse'], correctIndex: 0 }, { q: 'La práctica diaria recomendada dura…', options: ['10–15 minutos', '60 minutos', '1–2 horas', 'No se recomienda practicar a diario'], correctIndex: 0 } ] }, { id: 'tpl-periferia-3', name: 'Comprensión — Periferia (III)', questions: [ { q: 'El ejercicio “Periferia flash” exige…', options: ['Mantener fijación central', 'Mover la cabeza', 'Mirar solo el lado derecho', 'Cerrar los ojos entre flashes'], correctIndex: 0 }, { q: 'Un criterio de progreso en Periferia es…', options: ['Reducir ms de flash o aumentar distancia lateral', 'Disminuir contraste del texto', 'Aumentar brillo de pantalla', 'Reducir tamaño de fuente únicamente'], correctIndex: 0 }, { q: 'Las tablas de Schulte entrenan sobre todo…', options: ['Atención y percepción periférica', 'Memoria a muy largo plazo', 'Ortografía', 'Caligrafía'], correctIndex: 0 } ] } ]; localStorage.setItem(QS_KEY, JSON.stringify(obj)); } } catch {} }

function loadProgress() { try { const raw = localStorage.getItem(LS_KEY); return raw ? JSON.parse(raw) : { sessions: [] }; } catch { return { sessions: [] }; } }

function saveProgress(data) { try { localStorage.setItem(LS_KEY, JSON.stringify(data)); } catch {} }

// --- Preferencias de interfaz (tema y tipografía) --- const UI_KEY = "lecturaRapida_ui_v1"; function loadUi() { try { const raw = localStorage.getItem(UI_KEY); return raw ? JSON.parse(raw) : { theme: 'system', fontFamily: 'system', rsvpSize: 48, pacerSize: 18, lineHeight: 1.6, letterSpacing: 0 }; } catch { return { theme: 'system', fontFamily: 'system', rsvpSize: 48, pacerSize: 18, lineHeight: 1.6, letterSpacing: 0 }; } } function saveUi(u) { try { localStorage.setItem(UI_KEY, JSON.stringify(u)); } catch {} }

const ThemeContext = React.createContext({ isDark: false, theme: 'system', setTheme: () => {} }); const UiContext = React.createContext({ ui: loadUi(), setUi: () => {} });

function formatTime(ms) { const s = Math.floor(ms / 1000); const m = Math.floor(s / 60); const ss = String(s % 60).padStart(2, "0"); return ${m}:${ss}; }

// Texto de muestra (puede pegar cualquier texto largo en Configuración de cada ejercicio) const SAMPLE_TEXT = La lectura eficaz no consiste solo en aumentar la velocidad, sino en modular el ritmo sin sacrificar la comprensión.  Para lograrlo, entrenamos fijaciones más cortas, sacádicos más amplios y una atención flexible.  Practicar con un metrónomo visual o con RSVP permite ajustar la cadencia sin forzar los ojos.  El objetivo no es competir, sino leer con más comodidad, foco y disfrute.;

const FONT_MAP = { system: 'system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif', serif: 'Georgia, Cambria, "Times New Roman", Times, serif', kindleSerif: 'Bookerly, Literata, Merriweather, Georgia, serif', kindleSans: 'Amazon Ember, Helvetica Neue, Inter, Arial, Noto Sans, sans-serif', caecilia: 'Caecilia, Charter, Spectral, Georgia, serif', baskerville: 'Baskerville, Libre Baskerville, Times New Roman, serif', palatino: 'Palatino, Palatino Linotype, URW Palladio L, Book Antiqua, Georgia, serif', georgia: 'Georgia, Cambria, Times New Roman, serif', openDyslexic: 'OpenDyslexic, Atkinson Hyperlegible, Arial, Noto Sans, sans-serif' };

// -------------------- App -------------------- export default function App() { const [tab, setTab] = useState("inicio"); const [progress, setProgress] = useState(loadProgress()); const [ui, setUi] = useState(loadUi()); const [theme, setTheme] = useState(ui.theme || 'system'); const [showOnboarding, setShowOnboarding] = useState(() => !localStorage.getItem('onboarding_done_v1')); const [reminderBanner, setReminderBanner] = useState(null);

useEffect(() => { saveProgress(progress); }, [progress]); useEffect(() => { saveUi({ ...ui, theme }); }, [ui, theme]);

useEffect(() => { if ("serviceWorker" in navigator) { navigator.serviceWorker.register("/sw.js").catch(() => {}); } }, []);

const isDark = React.useMemo(() => { if (theme === 'system') { return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } return theme === 'dark'; }, [theme]); useEffect(() => { const root = document.documentElement; if (isDark) root.classList.add('dark'); else root.classList.remove('dark'); }, [isDark]);

useEffect(() => { ensureDefaultQuizzes(); }, []);

const addSession = (entry) => { setProgress((p) => ({ ...p, sessions: [...p.sessions, entry] })); };

return ( <ThemeContext.Provider value={{ isDark, theme, setTheme }}> <UiContext.Provider value={{ ui, setUi }}> <div className={min-h-screen ${isDark ? 'bg-slate-900 text-slate-100' : 'bg-slate-50 text-slate-900'}} style={{ fontFamily: FONT_MAP[ui.fontFamily || 'system'] }}> <Header onNavigate={setTab} active={tab} /> {reminderBanner && ( <div className="mx-auto max-w-5xl px-4 mt-2"> <div className="bg-amber-50 border border-amber-200 text-amber-800 rounded-xl px-3 py-2 text-sm flex items-center justify-between"> <span>{reminderBanner}</span> <button className="text-xs underline" onClick={() => setReminderBanner(null)}>Ocultar</button> </div> </div> )} {showOnboarding && ( <OnboardingModal progress={progress} onFinish={(settings) => { try { const prev = JSON.parse(localStorage.getItem('plan_settings_v1')) || {}; localStorage.setItem('plan_settings_v1', JSON.stringify({ targetWPM: settings?.targetWPM ?? prev.targetWPM ?? 300, minComp: settings?.minComp ?? prev.minComp ?? 70, durations: prev.durations || { schulte: 2, periferia: 3, rsvp: 5, pacer: 5 }, reminderTime: prev.reminderTime || '08:00' })); } catch {} localStorage.setItem('onboarding_done_v1', '1'); setShowOnboarding(false); }} setTab={setTab} /> )} <main className="max-w-5xl mx-auto p-4 pb-24"> {tab === "inicio" && <Intro />} {tab === "test" && <BaselineTest addSession={addSession} />} {tab === "rsvp" && <RSVPTrainer addSession={addSession} goToTab={setTab} />} {tab === "pacer" && <PacerTrainer addSession={addSession} goToTab={setTab} />} {tab === "schulte" && <SchulteTrainer addSession={addSession} />} {tab === "periferia" && <PeripheralTrainer addSession={addSession} />} {tab === "plan" && <PlanDaily addSession={addSession} progress={progress} />} {tab === "comp" && <ComprehensionCenter addSession={addSession} progress={progress} />} {tab === "progreso" && <ProgressView progress={progress} />} </main> <Footer /> </div> </UiContext.Provider> </ThemeContext.Provider> ); }

// -------------------- UI básicos -------------------- function Header({ onNavigate, active }) { const { isDark, theme, setTheme } = React.useContext(ThemeContext); const items = [ { id: "inicio", label: "Inicio" }, { id: "test", label: "Test base" }, { id: "rsvp", label: "RSVP" }, { id: "pacer", label: "Pacer" }, { id: "schulte", label: "Schulte" }, { id: "periferia", label: "Periferia" }, { id: "comp", label: "Comprensión" }, { id: "plan", label: "Plan diario" }, { id: "progreso", label: "Progreso" }, ]; return ( <header className={sticky top-0 z-40 ${isDark ? 'bg-slate-800/90 border-slate-700' : 'bg-white/90 border-slate-200'} backdrop-blur border-b}> <div className="max-w-5xl mx-auto px-4 py-3 flex items-center gap-3 justify-between"> <div className="font-bold">LecturaRápida</div> <nav className="flex gap-2 overflow-auto"> {items.map((it) => ( <button key={it.id} onClick={() => onNavigate(it.id)} className={px-3 py-2 rounded-xl text-sm whitespace-nowrap ${ active === it.id ? "bg-slate-900 text-white" : isDark ? "bg-slate-700 hover:bg-slate-600" : "bg-slate-100 hover:bg-slate-200" }} > {it.label} </button> ))} </nav> <div className="flex items-center gap-2"> <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')} className={${isDark ? 'bg-slate-700 hover:bg-slate-600' : 'bg-slate-100 hover:bg-slate-200'} px-3 py-2 rounded-xl text-sm} title="Alternar tema"> {theme === 'dark' ? '☾ Oscuro' : '☼ Claro'} </button> </div> </div> </header> ); }

function Footer() { const { isDark } = React.useContext(ThemeContext); return ( <footer className={${isDark ? 'bg-slate-800/95 border-slate-700' : 'bg-white/95 border-slate-200'} fixed bottom-0 inset-x-0 backdrop-blur border-t}> <div className="max-w-5xl mx-auto px-4 py-2 text-xs flex flex-wrap items-center gap-2 justify-between"> <div>© {new Date().getFullYear()} LecturaRápida — MVP educativo</div> <div>Recomendación: entrenar 10–15 min/día. Priorice comprensión sobre velocidad.</div> </div> </footer> ); }

function Card({ title, subtitle, children, actions }) { const { isDark } = React.useContext(ThemeContext); return ( <section className={${isDark ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-200'} rounded-2xl shadow-sm border p-4 mb-4}> <div className="flex items-start justify-between gap-4 mb-3"> <div> <h2 className="text-lg font-semibold">{title}</h2> {subtitle && ( <p className="text-sm opacity-80 mt-0.5">{subtitle}</p> )} </div> {actions} </div> <div>{children}</div> </section> ); }

// -------------------- Intro -------------------- function Intro() { return ( <div className="grid gap-4 md:grid-cols-2"> <Card
title="Método de entrenamiento"
subtitle="Evidencia aplicada a práctica diaria"
> <ul className="list-disc pl-5 space-y-2 text-sm text-slate-700"> <li> <span className="font-medium">RSVP</span>: ajusta el ritmo y reduce fijaciones largas. </li> <li> <span className="font-medium">Pacer visual</span>: guía la mirada y disminuye regresiones. </li> <li> <span className="font-medium">Schulte</span>: amplía el foco y la atención periférica. </li> <li> <span className="font-medium">Periferia flash</span>: entrena percepción lateral manteniendo fijación. </li> </ul> <p className="text-sm text-slate-600 mt-3"> Sugerencia de rutina (10–15 min): 2 min de Schulte, 2–3 min de Periferia, 4–5 min de RSVP, 3–5 min de Pacer con un texto real. </p> </Card> <Card title="Sugerencias de uso"> <ul className="list-disc pl-5 space-y-2 text-sm text-slate-700"> <li>Evite movimientos de cabeza: solo ojos.</li> <li>Aumente gradualmente el WPM si la comprensión ≥ 70% (auto-reporte).</li> <li>Descanse la vista (20–20–20) cada ~10 min.</li> <li>Preferible pantalla grande o móvil en horizontal para Pacer.</li> </ul> </Card> </div> ); }

// -------------------- Test base -------------------- function BaselineTest({ addSession }) { const [text, setText] = useState(SAMPLE_TEXT); const [running, setRunning] = useState(false); const [startAt, setStartAt] = useState(null); const [endAt, setEndAt] = useState(null); const [comprehension, setComprehension] = useState(80);

const words = useMemo(() => text.trim().split(/\s+/).filter(Boolean), [text]);

const handleStart = () => { setStartAt(Date.now()); setEndAt(null); setRunning(true); }; const handleStop = () => { setEndAt(Date.now()); setRunning(false); };

const wpm = useMemo(() => { if (!startAt || !endAt) return 0; const minutes = (endAt - startAt) / 60000; if (minutes <= 0) return 0; return Math.round(words.length / minutes); }, [startAt, endAt, words.length]);

const handleSave = () => { if (!endAt || !startAt) return; addSession({ type: "baseline", date: new Date().toISOString(), wpm, comprehension, }); alert(Guardado — WPM: ${wpm}, Comprensión: ${comprehension}%); };

return ( <Card
title="Test base de velocidad"
subtitle="Lea el texto completo. Inicie y detenga el cronómetro para calcular su WPM."
> <div className="flex flex-col gap-3"> <textarea className="w-full h-40 p-3 border rounded-xl focus:outline-none focus:ring" value={text} onChange={(e) => setText(e.target.value)} /> <div className="flex items-center gap-2"> {!running ? ( <button
onClick={handleStart}
className="px-4 py-2 rounded-xl bg-emerald-600 text-white"
> Iniciar </button> ) : ( <button
onClick={handleStop}
className="px-4 py-2 rounded-xl bg-rose-600 text-white"
> Detener </button> )} <div className="text-sm text-slate-600"> Tiempo: {startAt ? formatTime((endAt || Date.now()) - startAt) : "—"} </div> <div className="ml-auto text-sm font-medium">WPM estimado: {wpm || "—"}</div> </div> <div className="flex items-center gap-3"> <label className="text-sm">Comprensión (auto-reporte %)</label> <input type="range" min={0} max={100} value={comprehension} onChange={(e) => setComprehension(Number(e.target.value))} /> <div className="w-10 text-right text-sm">{comprehension}%</div> </div> <div> <button
onClick={handleSave}
disabled={!endAt}
className="px-4 py-2 rounded-xl bg-slate-900 text-white disabled:opacity-50"
> Guardar resultado </button> </div> </div> </Card> ); }

// -------------------- RSVP Trainer -------------------- function RSVPTrainer({ addSession, goToTab }) { const { ui } = React.useContext(UiContext); const { isDark } = React.useContext(ThemeContext); const [text, setText] = useState(SAMPLE_TEXT); const [wpm, setWpm] = useState(300); const [chunk, setChunk] = useState(1); const [running, setRunning] = useState(false); const [index, setIndex] = useState(0); const [startAt, setStartAt] = useState(null);

const words = useMemo(() => text.trim().split(/\s+/).filter(Boolean), [text]); const chunks = useMemo(() => { const arr = []; for (let i = 0; i < words.length; i += chunk) arr.push(words.slice(i, i + chunk).join(" ")); return arr; }, [words, chunk]);

const intervalRef = useRef(null);

useEffect(() => { if (!running) return; const delay = Math.max(30, Math.round(60000 / (wpm / Math.max(1, chunk)))); intervalRef.current = setInterval(() => { setIndex((i) => { if (i >= chunks.length - 1) { clearInterval(intervalRef.current); setRunning(false); return i; } return i + 1; }); }, delay); return () => clearInterval(intervalRef.current); }, [running, wpm, chunk, chunks.length]);

const current = chunks[index] || "";

const handleStart = () => { setIndex(0); setStartAt(Date.now()); setRunning(true); }; const handleStop = () => { setRunning(false); }; const handleSave = () => { const endAt = Date.now(); const minutes = (endAt - (startAt || endAt)) / 60000; const realWpm = minutes > 0 ? Math.round(words.length / minutes) : wpm; addSession({ type: "rsvp", date: new Date().toISOString(), wpm: realWpm, params: { wpm, chunk } }); alert(Guardado — WPM efectivo: ${realWpm}); };

return ( <div className="grid gap-4 md:grid-cols-2"> <Card title="RSVP" subtitle="Palabras/chunk a ritmo fijo. Ajuste WPM y Chunk."> <div className="flex items-center gap-4 flex-wrap mb-3"> <div className="text-sm">WPM objetivo: {wpm}</div> <input type="range" min={120} max={900} value={wpm} onChange={(e) => setWpm(Number(e.target.value))} /> <div className="text-sm">Chunk: {chunk}</div> <input type="range" min={1} max={4} value={chunk} onChange={(e) => setChunk(Number(e.target.value))} /> {!running ? ( <button onClick={handleStart} className="px-3 py-2 rounded-xl bg-emerald-600 text-white">Iniciar</button> ) : ( <button onClick={handleStop} className="px-3 py-2 rounded-xl bg-rose-600 text-white">Detener</button> )} <button onClick={handleSave} className="px-3 py-2 rounded-xl bg-slate-900 text-white">Guardar</button> <button onClick={() => goToTab && goToTab('comp')} className="px-3 py-2 rounded-xl bg-indigo-600 text-white">Evaluar comprensión</button> </div> <div className="h-40 md:h-56 grid place-items-center select-none"> <div className="font-semibold tracking-wide" style={{ fontSize: (ui.rsvpSize || 48) + 'px', letterSpacing: (ui.letterSpacing || 0) + 'em', lineHeight: 1.1 }}> {current.split("").map((ch, i) => ( <span key={i} className={i === Math.floor(current.length * 0.45) ? "underline decoration-4" : ""}>{ch}</span> ))} </div> </div> </Card> <Card title="Texto" subtitle="Pegue su propio texto (artículo / libro)"> <textarea className="w-full h-64 p-3 border rounded-xl focus:outline-none focus:ring" value={text} onChange={(e) => setText(e.target.value)} /> <p className="text-xs text-slate-500 mt-2"> Consejo: suba WPM de 30 en 30 cuando la comprensión percibida sea ≥ 70%. </p> </Card> </div> ); }

// -------------------- Pacer Trainer -------------------- function PacerTrainer({ addSession, goToTab }) { const { ui } = React.useContext(UiContext); const { isDark } = React.useContext(ThemeContext); const [text, setText] = useState(SAMPLE_TEXT.repeat(8)); const [wpm, setWpm] = useState(240); const [visibleWindow, setVisibleWindow] = useState(2); const [running, setRunning] = useState(false); const containerRef = useRef(null); const [wordCount, setWordCount] = useState(0); const [startAt, setStartAt] = useState(null);

const lines = useMemo(() => text.split(/\n+/), [text]);

useEffect(() => { if (!running) return; const words = text.trim().split(/\s+/).filter(Boolean); setWordCount(words.length);

const msPerWord = 60000 / wpm;
const msTotal = words.length * msPerWord;
const start = Date.now();
setStartAt(start);

let raf;
const step = () => {
  const el = containerRef.current;
  if (!el) return;
  const t = Date.now() - start;
  const p = Math.min(1, t / msTotal);
  el.scrollTop = p * (el.scrollHeight - el.clientHeight);
  if (p < 1 && running) raf = requestAnimationFrame(step);
};
raf = requestAnimationFrame(step);
return () => cancelAnimationFrame(raf);

}, [running, wpm, text]);

const handleSave = () => { if (!startAt) return; const endAt = Date.now(); const minutes = (endAt - startAt) / 60000; const realWpm = minutes > 0 ? Math.round(wordCount / minutes) : wpm; addSession({ type: "pacer", date: new Date().toISOString(), wpm: realWpm, params: { wpm, visibleWindow } }); alert(Guardado — WPM efectivo: ${realWpm}); };

return ( <div className="grid gap-4 md:grid-cols-2"> <Card title="Pacer visual" subtitle="Ventana de lectura y desplazamiento automático"> <div className="flex items-center gap-3 flex-wrap mb-3"> <div className="text-sm">WPM objetivo: {wpm}</div> <input type="range" min={150} max={600} value={wpm} onChange={(e) => setWpm(Number(e.target.value))} /> <div className="text-sm">Ventana (líneas): {visibleWindow}</div> <input type="range" min={1} max={6} value={visibleWindow} onChange={(e) => setVisibleWindow(Number(e.target.value))} /> {!running ? ( <button onClick={() => setRunning(true)} className="px-3 py-2 rounded-xl bg-emerald-600 text-white">Iniciar</button> ) : ( <button onClick={() => setRunning(false)} className="px-3 py-2 rounded-xl bg-rose-600 text-white">Detener</button> )} <button onClick={handleSave} className="px-3 py-2 rounded-xl bg-slate-900 text-white">Guardar</button> <button onClick={() => goToTab && goToTab('comp')} className="px-3 py-2 rounded-xl bg-indigo-600 text-white">Evaluar comprensión</button> </div> <div ref={containerRef} className={h-64 overflow-y-auto border rounded-xl p-4 ${isDark ? 'bg-slate-800 border-slate-700' : 'bg-slate-50 border-slate-200'} relative} style={{ maskImage: linear-gradient(to bottom, transparent 0, black 10%, black ${visibleWindow * 16}%, transparent ${visibleWindow * 16 + 48}%) }} > <div className="prose prose-sm max-w-none"> {lines.map((ln, i) => ( <p key={i} className="tracking-wide" style={{ fontSize: (ui.pacerSize || 18) + 'px', lineHeight: ui.lineHeight || 1.6, letterSpacing: (ui.letterSpacing || 0) + 'em' }}>{ln}</p> ))} </div> </div> <p className="text-xs text-slate-500 mt-2">La máscara limita el texto visible para desalentar regresiones.</p> </Card> <Card title="Texto" subtitle="Pegue aquí su material de lectura real"> <textarea className="w-full h-64 p-3 border rounded-xl" value={text} onChange={(e) => setText(e.target.value)} /> </Card> </div> ); }

// -------------------- Schulte Trainer -------------------- function generateShulte(n = 5) { const size = n * n; const nums = Array.from({ length: size }, (_, i) => i + 1); for (let i = nums.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [nums[i], nums[j]] = [nums[j], nums[i]]; } return { n, cells: nums }; }

function SchulteTrainer({ addSession }) { const [n, setN] = useState(5); const [grid, setGrid] = useState(() => generateShulte(5)); const [next, setNext] = useState(1); const [startAt, setStartAt] = useState(null); const [doneAt, setDoneAt] = useState(null);

useEffect(() => { setGrid(generateShulte(n)); setNext(1); setStartAt(null); setDoneAt(null); }, [n]);

const handleCell = (val) => { if (doneAt) return; if (val !== next) return; if (!startAt) setStartAt(Date.now()); if (val === n * n) { setDoneAt(Date.now()); return; } setNext((v) => v + 1); };

const elapsed = doneAt && startAt ? doneAt - startAt : 0;

const handleSave = () => { if (!elapsed) return; addSession({ type: "schulte", date: new Date().toISOString(), seconds: Math.round(elapsed / 1000), params: { n } }); alert(Guardado — Tiempo: ${Math.round(elapsed / 1000)} s); };

return ( <Card title="Tabla de Schulte" subtitle="Toque números en orden del 1 al máximo"> <div className="flex items-center gap-3 mb-3"> <div className="text-sm">Tamaño: {n}×{n}</div> <input type="range" min={3} max={6} value={n} onChange={(e) => setN(Number(e.target.value))} /> <button onClick={() => { setGrid(generateShulte(n)); setNext(1); setStartAt(null); setDoneAt(null); }} className="px-3 py-2 rounded-xl bg-slate-900 text-white">Nuevo</button> <div className="ml-auto text-sm text-slate-600">Tiempo: {startAt ? formatTime((doneAt || Date.now()) - startAt) : "—"}</div> <button onClick={handleSave} disabled={!elapsed} className="px-3 py-2 rounded-xl bg-emerald-600 text-white disabled:opacity-50">Guardar</button> </div> <div className="grid gap-2" style={{ gridTemplateColumns: repeat(${n}, minmax(0, 1fr)) }}> {grid.cells.map((val) => ( <button key={val} onClick={() => handleCell(val)} className={aspect-square rounded-xl text-xl md:text-2xl font-semibold grid place-items-center border ${ val === next ? "bg-emerald-50 border-emerald-300" : "bg-white border-slate-200" }} > {val} </button> ))} </div> <p className="text-xs text-slate-500 mt-2">Objetivo: completar más rápido manteniendo mirada central y visión periférica activa.</p> </Card> ); }

// -------------------- Periferia Flash -------------------- function PeripheralTrainer({ addSession }) { const { isDark } = React.useContext(ThemeContext); const [leftWord, setLeftWord] = useState("lado"); const [rightWord, setRightWord] = useState("derecho"); const [distance, setDistance] = useState(30); const [flashMs, setFlashMs] = useState(300); const [running, setRunning] = useState(false); const [shown, setShown] = useState(false); const [correct, setCorrect] = useState(null);

const wordsPool = ["casa", "árbol", "libro", "tiempo", "camino", "foco", "ritmo", "mente", "luz", "cuerpo", "notas", "ideas"];

const trigger = () => { const lw = wordsPool[Math.floor(Math.random() * wordsPool.length)]; let rw = wordsPool[Math.floor(Math.random() * wordsPool.length)]; if (rw === lw) rw = wordsPool[(wordsPool.indexOf(rw) + 1) % wordsPool.length]; setLeftWord(lw); setRightWord(rw); setShown(true); setTimeout(() => setShown(false), flashMs); };

useEffect(() => { if (!running) return; const id = setInterval(trigger, flashMs * 2.2); trigger(); return () => clearInterval(id); }, [running, flashMs]);

const handleAnswer = (side) => { const ok = side === "left" ? leftWord.length >= rightWord.length : rightWord.length >= leftWord.length; setCorrect(ok); setTimeout(() => setCorrect(null), 600); };

return ( <Card title="Periferia — flash lateral" subtitle="Mantenga la vista en la cruz central. Indique dónde vio la palabra más larga."> <div className="flex items-center gap-3 flex-wrap mb-3"> <div className="text-sm">Distancia lateral (%): {distance}</div> <input type="range" min={15} max={42} value={distance} onChange={(e) => setDistance(Number(e.target.value))} /> <div className="text-sm">Flash (ms): {flashMs}</div> <input type="range" min={120} max={700} value={flashMs} onChange={(e) => setFlashMs(Number(e.target.value))} /> {!running ? ( <button onClick={() => setRunning(true)} className="px-3 py-2 rounded-xl bg-emerald-600 text-white">Iniciar</button> ) : ( <button onClick={() => setRunning(false)} className="px-3 py-2 rounded-xl bg-rose-600 text-white">Detener</button> )} </div> <div className={h-64 grid place-items-center relative border rounded-xl ${isDark ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-200'} overflow-hidden}> <div className="absolute inset-0 grid grid-cols-3"> <div className="relative"> {shown && ( <div className="absolute top-1/2 -translate-y-1/2 text-2xl font-semibold w-full text-right pr-4" style={{ left: ${distance * -0.2}% }} > {leftWord} </div> )} </div> <div className="grid place-items-center"> <div className="text-3xl">✚</div> </div> <div className="relative"> {shown && ( <div className="absolute top-1/2 -translate-y-1/2 text-2xl font-semibold w-full text-left pl-4" style={{ right: ${distance * -0.2}% }} > {rightWord} </div> )} </div> </div> </div> <div className="flex items-center gap-3 mt-3"> <button onClick={() => handleAnswer("left")} className="px-3 py-2 rounded-xl bg-slate-900 text-white">Izquierda más larga</button> <button onClick={() => handleAnswer("right")} className="px-3 py-2 rounded-xl bg-slate-900 text-white">Derecha más larga</button> {correct != null && ( <span className={text-sm ${correct ? "text-emerald-700" : "text-rose-700"}}> {correct ? "✔ Correcto" : "✖ Intente nuevamente"} </span> )} </div> <p className="text-xs text-slate-500 mt-2">Progrese reduciendo ms o aumentando distancia. 1–2 min por serie.</p> </Card> ); }

// -------------------- Progreso -------------------- function ProgressView({ progress }) { const wpmSessions = progress.sessions .filter((s) => typeof s.wpm === "number") .map((s, i) => ({ i, date: new Date(s.date).toLocaleDateString(), wpm: s.wpm, tipo: s.type }));

const exportAll = () => { const settings = (() => { try { return JSON.parse(localStorage.getItem('plan_settings_v1')); } catch { return null; } })(); const quizzes = loadQuizzes(); const doneDays = {}; for (let i = 0; i < 120; i++) { const dt = new Date(Date.now() - i * 86400000); const k = 'plan_done_' + dt.toISOString().slice(0, 10); const v = localStorage.getItem(k); if (v) doneDays[k] = v; } const payload = { version: 1, exportedAt: new Date().toISOString(), progress: loadProgress(), settings, quizzes, doneDays }; const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = lectura-rapida-backup-${new Date().toISOString().slice(0,10)}.json; a.click(); URL.revokeObjectURL(url); };

const importAll = async (file) => { const text = await file.text(); const data = JSON.parse(text); if (data.progress) localStorage.setItem(LS_KEY, JSON.stringify(data.progress)); if (data.settings) localStorage.setItem('plan_settings_v1', JSON.stringify(data.settings)); if (data.quizzes) localStorage.setItem(QS_KEY, JSON.stringify(data.quizzes)); if (data.doneDays) { Object.entries(data.doneDays).forEach(([k, v]) => localStorage.setItem(k, v)); } alert('Datos importados. Se recargará la aplicación para aplicar los cambios.'); location.reload(); };

return ( <div className="grid gap-4 md:grid-cols-2"> <Card title="Histórico de WPM" subtitle="Resultados guardados (baseline, RSVP, Pacer)"> {wpmSessions.length === 0 ? ( <p className="text-sm text-slate-600">Aún no hay sesiones guardadas.</p> ) : ( <div className="h-64"> <ResponsiveContainer width="100%" height="100%"> <LineChart data={wpmSessions}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="date" /> <YAxis domain={[0, 'dataMax + 60']} /> <Tooltip /> <Line type="monotone" dataKey="wpm" strokeWidth={2} dot /> </LineChart> </ResponsiveContainer> </div> )} </Card> <Card title="Consejos según su registro"> <Advice sessions={progress.sessions} /> </Card> <Card title="Exportar / Importar" subtitle="Copia de seguridad de su progreso, configuración y cuestionarios"> <div className="flex flex-wrap items-center gap-3 text-sm"> <button onClick={exportAll} className="px-3 py-2 rounded-xl bg-slate-900 text-white">Exportar JSON</button> <label className="inline-flex items-center gap-2"> <span>Importar JSON</span> <input type="file" accept="application/json" onChange={(e) => e.target.files && importAll(e.target.files[0])} /> </label> <p className="text-xs text-slate-500">Nota: al importar se sobrescriben sus datos locales.</p> </div> </Card> </div> ); }

function Advice({ sessions }) { if (!sessions || sessions.length === 0) return ( <p className="text-sm text-slate-600">Cuando registre 3 o más sesiones le daremos recomendaciones automáticas.</p> ); const last = sessions[sessions.length - 1]; const wpms = sessions.map((s) => s.wpm).filter(Boolean); const avg = Math.round(wpms.reduce((a, b) => a + b, 0) / wpms.length); const quizScores = sessions.filter((s) => s.type === 'quiz').slice(-3).map((s) => s.score); const avgQuiz = quizScores.length ? Math.round(quizScores.reduce((a, b) => a + b, 0) / quizScores.length) : null;

return ( <ul className="list-disc pl-5 space-y-2 text-sm text-slate-700"> <li>WPM promedio: <span className="font-medium">{avg}</span>.</li> {avgQuiz != null && (<li>Comprensión reciente (promedio 3 últimos): <span className="font-medium">{avgQuiz}%</span>.</li>)} {last && last.type === "rsvp" && ( <li>Ha practicado con RSVP recientemente. Aumente +30 WPM si su comprensión promedio ≥ 70%.</li> )} {last && last.type === "pacer" && ( <li>Continúe con Pacer y reduzca la ventana visible a {Math.max(1, (last.params?.visibleWindow || 2) - 1)} líneas si no hay fatiga.</li> )} {last && last.type === "baseline" && ( <li>Haga 2–3 rondas de RSVP y una lectura real con Pacer antes de repetir el test base.</li> )} <li>Integre textos reales (estudio/trabajo) para transferir el entrenamiento.</li> </ul> ); }

// -------------------- Onboarding -------------------- function OnboardingModal({ progress, onFinish, setTab }) { const lastBaseline = [...(progress?.sessions || [])].reverse().find(s => s.type === 'baseline'); const lastWPM = lastBaseline?.wpm || null; const lastComp = lastBaseline?.comprehension ?? 80; const suggested = lastWPM ? Math.round(Math.min(lastWPM + 60, Math.max(180, lastWPM + 30))) : 300;

return ( <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-50 grid place-items-center p-4"> <div className="bg-white rounded-2xl shadow-xl max-w-xl w-full p-5 border border-slate-200"> <h3 className="text-lg font-semibold text-slate-800">Bienvenido/a — Configuración inicial</h3> <p className="text-sm text-slate-600 mt-1">Definiremos metas rápidas para su plan diario. Puede cambiarlas luego.</p> {lastWPM ? ( <div className="mt-3 text-sm text-slate-700"> <p>Último test base: <span className="font-medium">{lastWPM} WPM</span> • Comprensión: {lastComp}%</p> <p className="mt-2">Sugerencia de meta inicial: <span className="font-medium">{suggested} WPM</span> (≈ +30–60 WPM sobre su base).</p> <div className="mt-3 flex gap-2"> <button onClick={() => onFinish({ targetWPM: suggested, minComp: 70 })} className="px-3 py-2 rounded-xl bg-emerald-600 text-white">Aceptar sugerencia</button> <button onClick={() => { setTab('plan'); onFinish({}); }} className="px-3 py-2 rounded-xl bg-slate-900 text-white">Lo ajustaré manualmente</button> </div> </div> ) : ( <div className="mt-3 text-sm text-slate-700"> <p>No encontramos un <span className="font-medium">test base</span> guardado.</p> <p className="mt-1">Le sugerimos realizarlo ahora para calibrar su meta.</p> <div className="mt-3 flex gap-2"> <button onClick={() => setTab('test')} className="px-3 py-2 rounded-xl bg-slate-900 text-white">Ir a Test base</button> <button onClick={() => onFinish({ targetWPM: 300, minComp: 70 })} className="px-3 py-2 rounded-xl bg-emerald-600 text-white">Usar meta predeterminada (300 WPM)</button> </div> </div> )} <button className="mt-4 text-xs text-slate-500 underline" onClick={() => onFinish({})}>Omitir por ahora</button> </div> </div> ); }

// -------------------- Comprensión: Centro (plantillas + rendición) -------------------- function ComprehensionCenter({ addSession, progress }) { const [data, setData] = React.useState(loadQuizzes()); const [selId, setSelId] = React.useState(data.templates[0]?.id || null); const [mode, setMode] = React.useState('manage');

useEffect(() => { saveQuizzes(data); }, [data]);

const addTemplate = () => { const id = Math.random().toString(36).slice(2); const tpl = { id, name: Cuestionario ${data.templates.length + 1}, questions: [] }; setData((d) => ({ templates: [...d.templates, tpl] })); setSelId(id); }; const updateTemplate = (id, patch) => { setData((d) => ({ templates: d.templates.map(t => t.id === id ? { ...t, ...patch } : t) })); }; const addQuestion = (id) => { const q = { q: '', options: ['', '', '', ''], correctIndex: 0 }; setData((d) => ({ templates: d.templates.map(t => t.id === id ? { ...t, questions: [...t.questions, q] } : t) })); }; const removeQuestion = (id, idx) => { setData((d) => ({ templates: d.templates.map(t => t.id === id ? { ...t, questions: t.questions.filter((_,i)=> i!==idx) } : t) })); };

const tpl = data.templates.find(t => t.id === selId) || null;

return ( <div className="grid gap-4 md:grid-cols-2"> <Card title="Plantillas de cuestionarios" subtitle="Cree y edite preguntas de opción múltiple (4 alternativas)"> <div className="flex items-center gap-2 mb-3"> <select value={selId || ''} onChange={(e)=> setSelId(e.target.value || null)} className="border rounded-md p-2 text-sm"> {data.templates.map(t => <option key={t.id} value={t.id}>{t.name}</option>)} </select> <button onClick={addTemplate} className="px-3 py-2 rounded-xl bg-slate-900 text-white text-sm">Nueva plantilla</button> </div> {tpl ? ( <div className="space-y-3"> <input className="border rounded-md p-2 w-full text-sm" value={tpl.name} onChange={(e)=> updateTemplate(tpl.id, { name: e.target.value })} /> {tpl.questions.map((qq, i) => ( <div key={i} className="border rounded-xl p-3"> <div className="flex items-center justify-between"> <div className="text-sm font-medium">Pregunta {i+1}</div> <button className="text-xs text-rose-600" onClick={()=> removeQuestion(tpl.id, i)}>Eliminar</button> </div> <input className="mt-2 border rounded-md p-2 w-full text-sm" placeholder="Enunciado" value={qq.q} onChange={(e)=>{ const questions = tpl.questions.slice(); questions[i] = { ...qq, q: e.target.value }; updateTemplate(tpl.id, { questions }); }} /> <div className="grid grid-cols-2 gap-2 mt-2"> {qq.options.map((opt, j) => ( <label key={j} className="text-sm flex items-center gap-2"> <input type="radio" name={correct-${tpl.id}-${i}} checked={qq.correctIndex === j} onChange={()=>{ const questions = tpl.questions.slice(); questions[i] = { ...qq, correctIndex: j }; updateTemplate(tpl.id, { questions }); }} /> <input className="border rounded-md p-2 w-full text-sm" placeholder={Opción ${j+1}} value={opt} onChange={(e)=>{ const questions = tpl.questions.slice(); const options = qq.options.slice(); options[j] = e.target.value; questions[i] = { ...qq, options }; updateTemplate(tpl.id, { questions }); }} /> </label> ))} </div> </div> ))} <button onClick={()=> addQuestion(tpl.id)} className="px-3 py-2 rounded-xl bg-emerald-600 text-white text-sm">Añadir pregunta</button> </div> ) : ( <p className="text-sm text-slate-600">Cree una plantilla y agregue preguntas.</p> )} </Card>

<Card title="Rendir cuestionario" subtitle="Seleccione una plantilla y obtenga su % de comprensión">
    <QuizTaker
      templates={data.templates}
      onSaved={(res) => {
        addSession({ type: 'quiz', date: new Date().toISOString(), score: res.score, params: { quizId: res.quizId, from: 'center' } });
        alert(`Resultado guardado: ${res.score}%`);
      }}
    />
  </Card>
</div>

); }

function QuizTaker({ templates, onSaved }) { const [quizId, setQuizId] = React.useState(templates[0]?.id || ''); const quiz = templates.find(t => t.id === quizId) || null; const [answers, setAnswers] = React.useState({});

const submit = () => { if (!quiz || !quiz.questions.length) return alert('Seleccione una plantilla con preguntas.'); let correct = 0; quiz.questions.forEach((q, i) => { if (answers[i] === q.correctIndex) correct++; }); const score = Math.round((correct / quiz.questions.length) * 100); onSaved({ quizId, score }); };

return ( <div className="space-y-3"> <select value={quizId} onChange={(e)=> setQuizId(e.target.value)} className="border rounded-md p-2 text-sm"> {templates.map(t => <option key={t.id} value={t.id}>{t.name}</option>)} </select> {quiz ? ( <div className="space-y-3 max-h-80 overflow-auto pr-1"> {quiz.questions.length === 0 && (<p className="text-sm text-slate-600">Esta plantilla no tiene preguntas aún.</p>)} {quiz.questions.map((q, i) => ( <div key={i} className="border rounded-xl p-3"> <div className="text-sm font-medium">{i+1}. {q.q || '—'}</div> <div className="grid grid-cols-1 md:grid-cols-2 gap-2 mt-2"> {q.options.map((opt, j) => ( <label key={j} className="text-sm flex items-center gap-2"> <input type="radio" name={ans-${i}} checked={answers[i] === j} onChange={()=> setAnswers({ ...answers, [i]: j })} /> <span>{opt || Opción ${j+1}}</span> </label> ))} </div> </div> ))} </div> ) : ( <p className="text-sm text-slate-600">No hay cuestionarios disponibles.</p> )} <button onClick={submit} className="px-3 py-2 rounded-xl bg-indigo-600 text-white text-sm">Calcular comprensión</button> </div> ); }

// -------------------- Plan Diario -------------------- function PlanDaily({ addSession, progress }) { const { ui, setUi } = React.useContext(UiContext); const { theme, setTheme } = React.useContext(ThemeContext); const defaultSettings = { targetWPM: 300, minComp: 70, reminderTime: '08:00', durations: { schulte: 2, periferia: 3, rsvp: 5, pacer: 5 } }; const [settings, setSettings] = React.useState(() => { try { return JSON.parse(localStorage.getItem('plan_settings_v1')) ?? defaultSettings; } catch { return defaultSettings; } }); React.useEffect(() => { localStorage.setItem('plan_settings_v1', JSON.stringify(settings)); }, [settings]);

const todayKey = new Date().toISOString().slice(0,10); const emptyDone = { schulte: false, periferia: false, rsvp: false, pacer: false }; const [done, setDone] = React.useState(() => { try { return JSON.parse(localStorage.getItem('plan_done_' + todayKey)) ?? emptyDone; } catch { return emptyDone; } }); React.useEffect(() => { localStorage.setItem('plan_done_' + todayKey, JSON.stringify(done)); }, [done, todayKey]);

const [timer, setTimer] = React.useState({ task: null, start: null, elapsed: 0, running: false }); React.useEffect(() => { if (!timer.running) return; const id = setInterval(() => { setTimer((t) => ({ ...t, elapsed: (Date.now() - (t.start || Date.now())) / 1000 })); }, 500); return () => clearInterval(id); }, [timer.running]);

const startTask = (task) => setTimer({ task, start: Date.now(), elapsed: 0, running: true }); const stopTask = () => { setTimer((t) => ({ ...t, running: false })); const need = (settings.durations[timer.task] || 0) * 60; if (timer.elapsed >= need && timer.task) setDone((d) => ({ ...d, [timer.task]: true })); };

const countCompleted = ['schulte', 'periferia', 'rsvp', 'pacer'].filter((k) => done[k]).length;

const computeStreak = () => { let streak = 0; const today = new Date(); for (let i = 0; i < 60; i++) { const dt = new Date(today.getTime() - i * 86400000); const key = dt.toISOString().slice(0, 10); try { const day = JSON.parse(localStorage.getItem('plan_done_' + key)); if (day && ['schulte', 'periferia', 'rsvp', 'pacer'].every((k) => day[k])) streak++; else break; } catch { break; } } return streak; }; const streak = computeStreak();

const lastWpmList = (progress?.sessions || []).filter((s) => typeof s.wpm === 'number').slice(-3).map((s) => s.wpm); const avgLast = lastWpmList.length ? Math.round(lastWpmList.reduce((a, b) => a + b, 0) / lastWpmList.length) : 0; const target = settings.targetWPM; const quizScores = (progress?.sessions || []).filter((s) => s.type === 'quiz').slice(-3).map((s) => s.score); const avgQuiz = quizScores.length ? Math.round(quizScores.reduce((a, b) => a + b, 0) / quizScores.length) : null; const compOK = avgQuiz == null ? true : avgQuiz >= settings.minComp; const suggestedNext = compOK ? (avgLast ? Math.min(target, avgLast + 30) : target) : (avgLast || target);

const label = (k) => (k === 'schulte' ? 'Schulte' : k === 'periferia' ? 'Periferia' : k === 'rsvp' ? 'RSVP' : k === 'pacer' ? 'Pacer' : k);

return ( <div className="grid gap-4 md:grid-cols-2"> <Card title="Objetivo diario" subtitle="Plan automático de 4 bloques"> <p className="text-sm text-slate-700"> Meta de velocidad: <span className="font-medium">{target} WPM</span> • Comprensión mínima: <span className="font-medium">{settings.minComp}%</span> </p> <p className="text-sm text-slate-600 mt-1">Progreso de hoy: {countCompleted}/4 • Racha: {streak} día(s)</p> <p className="text-sm text-slate-600 mt-1">Sugerencia: practique RSVP a {suggestedNext} WPM y termine con Pacer en texto real.</p> </Card> <Card title="Checklist con temporizador"> {['schulte', 'periferia', 'rsvp', 'pacer'].map((k) => ( <div key={k} className="flex items-center justify-between border rounded-xl p-2 mb-2"> <div className="text-sm capitalize">{label(k)} — {settings.durations[k]} min</div> <div className="flex items-center gap-2"> {timer.running && timer.task === k ? ( <> <div className="text-xs text-slate-600">{Math.floor(timer.elapsed / 60)}:{String(Math.floor(timer.elapsed % 60)).padStart(2, '0')}</div> <button onClick={stopTask} className="px-2 py-1 rounded-lg bg-rose-600 text-white text-xs">Detener</button> </> ) : ( <button onClick={() => startTask(k)} className="px-2 py-1 rounded-lg bg-emerald-600 text-white text-xs">Empezar</button> )} <input type="checkbox" checked={!!done[k]} onChange={(e) => setDone((d) => ({ ...d, [k]: e.target.checked }))} /> </div> </div> ))} <p className="text-xs text-slate-500">Se marca automáticamente si cumple el tiempo. Puede marcar manualmente si ya entrenó.</p> </Card> <Card title="Ajustes del plan"> <div className="grid grid-cols-2 gap-3 text-sm"> <label className="flex items-center justify-between">WPM meta <input type="number" className="ml-2 border rounded-md p-1 w-24" value={settings.targetWPM} onChange={(e) => setSettings({ ...settings, targetWPM: Math.max(120, Number(e.target.value || 0)) })} /> </label> <label className="flex items-center justify-between">% comprensión <input type="number" className="ml-2 border rounded-md p-1 w-20" value={settings.minComp} onChange={(e) => setSettings({ ...settings, minComp: Math.min(100, Math.max(50, Number(e.target.value || 0))) })} /> </label> <label className="flex items-center justify-between">Recordatorio diario <input type="time" className="ml-2 border rounded-md p-1 w-28" value={settings.reminderTime} onChange={(e) => setSettings({ ...settings, reminderTime: e.target.value || '08:00' })} /> </label> {['schulte', 'periferia', 'rsvp', 'pacer'].map((k) => ( <label key={k} className="flex items-center justify-between capitalize">{label(k)} (min) <input type="number" className="ml-2 border rounded-md p-1 w-20" value={settings.durations[k]} onChange={(e) => setSettings({ ...settings, durations: { ...settings.durations, [k]: Math.max(1, Number(e.target.value || 0)) } })} /> </label> ))} </div> </Card> <Card title="Apariencia (modo y tipografía)" subtitle="Ajustes visuales para ergonomía en móvil"> <div className="grid md:grid-cols-2 gap-3 text-sm"> <label className="flex items-center justify-between">Tema <select className="ml-2 border rounded-md p-1" value={theme} onChange={(e)=> setTheme(e.target.value)}> <option value="system">Sistema</option> <option value="light">Claro</option> <option value="dark">Oscuro</option> </select> </label> <label className="flex items-center justify-between">Fuente <select className="ml-2 border rounded-md p-1" value={ui.fontFamily || 'system'} onChange={(e)=> setUi({ ...ui, fontFamily: e.target.value })}> <option value="system">Sans (sistema)</option> <option value="serif">Serif (sistema)</option> <option value="kindleSerif">Kindle — Serif (Bookerly‑like)</option> <option value="kindleSans">Kindle — Sans (Ember‑like)</option> <option value="caecilia">Caecilia (slab‑serif)</option> <option value="baskerville">Baskerville</option> <option value="palatino">Palatino</option> <option value="georgia">Georgia</option> <option value="openDyslexic">OpenDyslexic*</option> </select> </label> <label className="flex items-center justify-between">RSVP tamaño (px) <input type="range" min={28} max={72} className="ml-2 w-40" value={ui.rsvpSize || 48} onChange={(e)=> setUi({ ...ui, rsvpSize: Number(e.target.value) })} /> </label> <label className="flex items-center justify-between">Pacer tamaño (px) <input type="range" min={14} max={26} className="ml-2 w-40" value={ui.pacerSize || 18} onChange={(e)=> setUi({ ...ui, pacerSize: Number(e.target.value) })} /> </label> <label className="flex items-center justify-between">Interlineado <input type="range" min={1.4} max={2.0} step={0.05} className="ml-2 w-40" value={ui.lineHeight || 1.6} onChange={(e)=> setUi({ ...ui, lineHeight: Number(e.target.value) })} /> </label> <label className="flex items-center justify-between">Espaciado de letras (em) <input type="range" min={-0.01} max={0.04} step={0.005} className="ml-2 w-40" value={ui.letterSpacing || 0} onChange={(e)=> setUi({ ...ui, letterSpacing: Number(e.target.value) })} /> </label> </div> <p className="text-xs opacity-70 mt-2">* Se usará si está instalada en el dispositivo; de lo contrario, se aplicarán fuentes de respaldo.</p> </Card> </div> ); }

